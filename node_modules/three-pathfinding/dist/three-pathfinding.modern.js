import{BufferAttribute as t,BufferGeometry as e,Vector3 as r,Plane as n,Triangle as s,Color as o,Object3D as i,Mesh as h,SphereBufferGeometry as c,MeshBasicMaterial as a,BoxBufferGeometry as u,LineBasicMaterial as l,Line as p}from"three";class d{static roundNumber(t,e){const r=Math.pow(10,e);return Math.round(t*r)/r}static sample(t){return t[Math.floor(Math.random()*t.length)]}static distanceToSquared(t,e){var r=t.x-e.x,n=t.y-e.y,s=t.z-e.z;return r*r+n*n+s*s}static isPointInPoly(t,e){for(var r=!1,n=-1,s=t.length,o=s-1;++n<s;o=n)(t[n].z<=e.z&&e.z<t[o].z||t[o].z<=e.z&&e.z<t[n].z)&&e.x<(t[o].x-t[n].x)*(e.z-t[n].z)/(t[o].z-t[n].z)+t[n].x&&(r=!r);return r}static isVectorInPolygon(t,e,r){var n=1e5,s=-1e5,o=[];return e.vertexIds.forEach(t=>{n=Math.min(r[t].y,n),s=Math.max(r[t].y,s),o.push(r[t])}),!!(t.y<s+.5&&t.y>n-.5&&this.isPointInPoly(o,t))}static triarea2(t,e,r){return(r.x-t.x)*(e.z-t.z)-(e.x-t.x)*(r.z-t.z)}static vequal(t,e){return this.distanceToSquared(t,e)<1e-5}static mergeVertices(r,n=1e-4){n=Math.max(n,Number.EPSILON);for(var s={},o=r.getIndex(),i=r.getAttribute("position"),h=o?o.count:i.count,c=0,a=[],u=[],l=Math.log10(1/n),p=Math.pow(10,l),d=0;d<h;d++){var g=o?o.getX(d):d,f="";f+=~~(i.getX(g)*p)+",",f+=~~(i.getY(g)*p)+",",(f+=~~(i.getZ(g)*p)+",")in s?a.push(s[f]):(u.push(i.getX(g)),u.push(i.getY(g)),u.push(i.getZ(g)),s[f]=c,a.push(c),c++)}const v=new t(new Float32Array(u),i.itemSize,i.normalized),b=new e;return b.setAttribute("position",v),b.setIndex(a),b}}class g{constructor(t){this.content=[],this.scoreFunction=t}push(t){this.content.push(t),this.sinkDown(this.content.length-1)}pop(){const t=this.content[0],e=this.content.pop();return this.content.length>0&&(this.content[0]=e,this.bubbleUp(0)),t}remove(t){const e=this.content.indexOf(t),r=this.content.pop();e!==this.content.length-1&&(this.content[e]=r,this.scoreFunction(r)<this.scoreFunction(t)?this.sinkDown(e):this.bubbleUp(e))}size(){return this.content.length}rescoreElement(t){this.sinkDown(this.content.indexOf(t))}sinkDown(t){const e=this.content[t];for(;t>0;){const r=(t+1>>1)-1,n=this.content[r];if(!(this.scoreFunction(e)<this.scoreFunction(n)))break;this.content[r]=e,this.content[t]=n,t=r}}bubbleUp(t){const e=this.content.length,r=this.content[t],n=this.scoreFunction(r);for(;;){const s=t+1<<1,o=s-1;let i,h=null;if(o<e&&(i=this.scoreFunction(this.content[o]),i<n&&(h=o)),s<e&&this.scoreFunction(this.content[s])<(null===h?n:i)&&(h=s),null===h)break;this.content[t]=this.content[h],this.content[h]=r,t=h}}}class f{constructor(){this.portals=[]}push(t,e){void 0===e&&(e=t),this.portals.push({left:t,right:e})}stringPull(){const t=this.portals,e=[];let r,n,s,o=0,i=0,h=0;r=t[0].left,n=t[0].left,s=t[0].right,e.push(r);for(let c=1;c<t.length;c++){const a=t[c].left,u=t[c].right;if(d.triarea2(r,s,u)<=0){if(!(d.vequal(r,s)||d.triarea2(r,n,u)>0)){e.push(n),r=n,o=i,n=r,s=r,i=o,h=o,c=o;continue}s=u,h=c}if(d.triarea2(r,n,a)>=0){if(!(d.vequal(r,n)||d.triarea2(r,s,a)<0)){e.push(s),r=s,o=h,n=r,s=r,i=o,h=o,c=o;continue}n=a,i=c}}return 0!==e.length&&d.vequal(e[e.length-1],t[t.length-1].left)||e.push(t[t.length-1].left),this.path=e,e}}class v{constructor(){this.zones={}}static createZone(t,e=1e-4){return class{static buildZone(t,e){const n=this._buildNavigationMesh(t,e),s={};n.vertices.forEach(t=>{t.x=d.roundNumber(t.x,2),t.y=d.roundNumber(t.y,2),t.z=d.roundNumber(t.z,2)}),s.vertices=n.vertices;const o=this._buildPolygonGroups(n);return s.groups=new Array(o.length),o.forEach((t,e)=>{const n=new Map;t.forEach((t,e)=>{n.set(t,e)});const o=new Array(t.length);t.forEach((t,e)=>{const i=[];t.neighbours.forEach(t=>i.push(n.get(t)));const h=[];t.neighbours.forEach(e=>h.push(this._getSharedVerticesInOrder(t,e)));const c=new r(0,0,0);c.add(s.vertices[t.vertexIds[0]]),c.add(s.vertices[t.vertexIds[1]]),c.add(s.vertices[t.vertexIds[2]]),c.divideScalar(3),c.x=d.roundNumber(c.x,2),c.y=d.roundNumber(c.y,2),c.z=d.roundNumber(c.z,2),o[e]={id:e,neighbours:i,vertexIds:t.vertexIds,centroid:c,portals:h}}),s.groups[e]=o}),s}static _buildNavigationMesh(t,e){return t=d.mergeVertices(t,e),this._buildPolygonsFromGeometry(t)}static _buildPolygonGroups(t){const e=[],r=function t(e){e.neighbours.forEach(r=>{void 0===r.group&&(r.group=e.group,t(r))})};return t.polygons.forEach(t=>{void 0!==t.group?e[t.group].push(t):(t.group=e.length,r(t),e.push([t]))}),e}static _buildPolygonNeighbours(t,e){const r=new Set,n=e[t.vertexIds[1]],s=e[t.vertexIds[2]];return e[t.vertexIds[0]].forEach(e=>{e!==t&&(n.includes(e)||s.includes(e))&&r.add(e)}),n.forEach(e=>{e!==t&&s.includes(e)&&r.add(e)}),r}static _buildPolygonsFromGeometry(t){const e=[],n=[],s=t.attributes.position,o=t.index,i=[];for(let t=0;t<s.count;t++)n.push((new r).fromBufferAttribute(s,t)),i[t]=[];for(let r=0;r<t.index.count;r+=3){const t=o.getX(r),n=o.getX(r+1),s=o.getX(r+2),h={vertexIds:[t,n,s],neighbours:null};e.push(h),i[t].push(h),i[n].push(h),i[s].push(h)}return e.forEach(t=>{t.neighbours=this._buildPolygonNeighbours(t,i)}),{polygons:e,vertices:n}}static _getSharedVerticesInOrder(t,e){const r=t.vertexIds,n=r[0],s=r[1],o=r[2],i=e.vertexIds,h=i.includes(n),c=i.includes(s),a=i.includes(o);return h&&c&&a?Array.from(r):h&&c?[n,s]:c&&a?[s,o]:h&&a?[o,n]:(console.warn("Error processing navigation mesh neighbors; neighbors with <2 shared vertices found."),[])}}.buildZone(t,e)}setZoneData(t,e){this.zones[t]=e}getRandomNode(t,e,n,s){if(!this.zones[t])return new r;n=n||null,s=s||0;const o=[];return this.zones[t].groups[e].forEach(t=>{n&&s?d.distanceToSquared(n,t.centroid)<s*s&&o.push(t.centroid):o.push(t.centroid)}),d.sample(o)||new r}getClosestNode(t,e,r,n=!1){const s=this.zones[e].vertices;let o=null,i=Infinity;return this.zones[e].groups[r].forEach(e=>{const r=d.distanceToSquared(e.centroid,t);r<i&&(!n||d.isVectorInPolygon(t,e,s))&&(o=e,i=r)}),o}findPath(t,e,n,s){const o=this.zones[n].groups[s],i=this.zones[n].vertices,h=this.getClosestNode(t,n,s,!0),c=this.getClosestNode(e,n,s,!0);if(!h||!c)return null;const a=class{static init(t){for(let e=0;e<t.length;e++){const r=t[e];r.f=0,r.g=0,r.h=0,r.cost=1,r.visited=!1,r.closed=!1,r.parent=null}}static cleanUp(t){for(let e=0;e<t.length;e++){const r=t[e];delete r.f,delete r.g,delete r.h,delete r.cost,delete r.visited,delete r.closed,delete r.parent}}static heap(){return new g(function(t){return t.f})}static search(t,e,r){this.init(t);const n=this.heap();for(n.push(e);n.size()>0;){const e=n.pop();if(e===r){let t=e;const r=[];for(;t.parent;)r.push(t),t=t.parent;return this.cleanUp(r),r.reverse()}e.closed=!0;const s=this.neighbours(t,e);for(let t=0,o=s.length;t<o;t++){const o=s[t];if(o.closed)continue;const i=e.g+o.cost,h=o.visited;if(!h||i<o.g){if(o.visited=!0,o.parent=e,!o.centroid||!r.centroid)throw new Error("Unexpected state");o.h=o.h||this.heuristic(o.centroid,r.centroid),o.g=i,o.f=o.g+o.h,h?n.rescoreElement(o):n.push(o)}}}return[]}static heuristic(t,e){return d.distanceToSquared(t,e)}static neighbours(t,e){const r=[];for(let n=0;n<e.neighbours.length;n++)r.push(t[e.neighbours[n]]);return r}}.search(o,h,c),u=function(t,e){for(var r=0;r<t.neighbours.length;r++)if(t.neighbours[r]===e.id)return t.portals[r]},l=new f;l.push(t);for(let t=0;t<a.length;t++){const e=a[t],r=a[t+1];if(r){const t=u(e,r);l.push(i[t[0]],i[t[1]])}}l.push(e),l.stringPull();const p=l.path.map(t=>new r(t.x,t.y,t.z));return p.shift(),p}}v.prototype.getGroup=function(){const t=new n;return function(e,r,n=!1){if(!this.zones[e])return null;let s=null,o=Math.pow(50,2);const i=this.zones[e];for(let e=0;e<i.groups.length;e++){const h=i.groups[e];for(const c of h){if(n&&(t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]],i.vertices[c.vertexIds[1]],i.vertices[c.vertexIds[2]]),Math.abs(t.distanceToPoint(r))<.01)&&d.isPointInPoly([i.vertices[c.vertexIds[0]],i.vertices[c.vertexIds[1]],i.vertices[c.vertexIds[2]]],r))return e;const h=d.distanceToSquared(c.centroid,r);h<o&&(s=e,o=h)}}return s}}(),v.prototype.clampStep=function(){const t=new r,e=new n,o=new s,i=new r;let h,c,a=new r;return function(r,n,s,u,l,p){const d=this.zones[u].vertices,g=this.zones[u].groups[l],f=[s],v={};v[s.id]=0,h=void 0,a.set(0,0,0),c=Infinity,e.setFromCoplanarPoints(d[s.vertexIds[0]],d[s.vertexIds[1]],d[s.vertexIds[2]]),e.projectPoint(n,t),i.copy(t);for(let e=f.pop();e;e=f.pop()){o.set(d[e.vertexIds[0]],d[e.vertexIds[1]],d[e.vertexIds[2]]),o.closestPointToPoint(i,t),t.distanceToSquared(i)<c&&(h=e,a.copy(t),c=t.distanceToSquared(i));const r=v[e.id];if(!(r>2))for(let t=0;t<e.neighbours.length;t++){const n=g[e.neighbours[t]];n.id in v||(f.push(n),v[n.id]=r+1)}}return p.copy(a),h}}();const b={PLAYER:new o(15631215).convertGammaToLinear(2.2).getHex(),TARGET:new o(14469912).convertGammaToLinear(2.2).getHex(),PATH:new o(41903).convertGammaToLinear(2.2).getHex(),WAYPOINT:new o(41903).convertGammaToLinear(2.2).getHex(),CLAMPED_STEP:new o(14472114).convertGammaToLinear(2.2).getHex(),CLOSEST_NODE:new o(4417387).convertGammaToLinear(2.2).getHex()};class w extends i{constructor(){super(),this._playerMarker=new h(new c(.25,32,32),new a({color:b.PLAYER})),this._targetMarker=new h(new u(.3,.3,.3),new a({color:b.TARGET})),this._nodeMarker=new h(new u(.1,.8,.1),new a({color:b.CLOSEST_NODE})),this._stepMarker=new h(new u(.1,1,.1),new a({color:b.CLAMPED_STEP})),this._pathMarker=new i,this._pathLineMaterial=new l({color:b.PATH,linewidth:2}),this._pathPointMaterial=new a({color:b.WAYPOINT}),this._pathPointGeometry=new c(.08),this._markers=[this._playerMarker,this._targetMarker,this._nodeMarker,this._stepMarker,this._pathMarker],this._markers.forEach(t=>{t.visible=!1,this.add(t)})}setPath(r){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);r=[this._playerMarker.position].concat(r);const n=new e;n.setAttribute("position",new t(new Float32Array(3*r.length),3));for(let t=0;t<r.length;t++)n.attributes.position.setXYZ(t,r[t].x,r[t].y+.2,r[t].z);this._pathMarker.add(new p(n,this._pathLineMaterial));for(let t=0;t<r.length-1;t++){const e=new h(this._pathPointGeometry,this._pathPointMaterial);e.position.copy(r[t]),e.position.y+=.2,this._pathMarker.add(e)}return this._pathMarker.visible=!0,this}setPlayerPosition(t){return this._playerMarker.position.copy(t),this._playerMarker.visible=!0,this}setTargetPosition(t){return this._targetMarker.position.copy(t),this._targetMarker.visible=!0,this}setNodePosition(t){return this._nodeMarker.position.copy(t),this._nodeMarker.visible=!0,this}setStepPosition(t){return this._stepMarker.position.copy(t),this._stepMarker.visible=!0,this}reset(){for(;this._pathMarker.children.length;)this._pathMarker.children[0].visible=!1,this._pathMarker.remove(this._pathMarker.children[0]);return this._markers.forEach(t=>{t.visible=!1}),this}}export{v as Pathfinding,w as PathfindingHelper};
//# sourceMappingURL=three-pathfinding.modern.js.map
